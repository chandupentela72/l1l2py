"""This module contains some useful functions.

There are four kind of functions:

* Range generators
    - :func:`linear_range`
    - :func:`geometric_range`
* Data Normalization 
    - :func:`center`
    - :func:`standardize`  
* Error calculation 
    - :func:`classification_error` 
    - :func:`balanced_classification_error`
    - :func:`regression_error`
* Cross Validation utilities
    - :func:`kfold_splits`  
    - :func:`stratified_kfold_splits` 

"""

import numpy as np

__all__ = ['linear_range', 'geometric_range',
           'standardize', 'center',
           'classification_error', 'balanced_classification_error',
                                   'regression_error',
            'kfold_splits', 'stratified_kfold_splits']

# Ranges functions ------------------------------------------------------------
def linear_range(min_value, max_value, number):
    """Returns a linear range of values.

    Returns ``number`` evenly spaced values from 
    ``min_value`` to ``max_value``.

    Parameters
    ----------
    min_value : float
    max_value : float
    number : int
    
    Returns
    -------
    range : ndarray

    See Also
    --------
    geometric_range
    numpy.linspace

    Examples
    --------
    >>> biolearning.tools.linear_range(0.0, 10.0, 4)
    array([0. , 3.33333333, 6.66666667, 10. ])
    >>> biolearning.tools.linear_range(0.0, 10.0, 2)
    array([  0.,  10.])
    >>> biolearning.tools.linear_range(0.0, 10.0, 1)
    array([  0., ])
    >>> biolearning.tools.linear_range(0.0, 10.0, 0)
    array([], dtype=float64)

    """
    return np.linspace(min_value, max_value, number)

def geometric_range(min_value, max_value, number):
    """Returns a geometric range of values.

    Returns ``number`` values from ``min_value`` 
    to ``max_value`` generated by a geometric sequence (see ``Notes``).

    Parameters
    ----------
    min_value : float
    max_value : float
    number : int

    Returns
    -------
    range : ndarray

    Raises
    ------
    ZeroDivisionError
        If ``min_value`` is ``0.0`` or ``number`` is ``1``

    See Also
    --------
    linear_range

    Notes
    -----
    The geometric sequence of :math:`n` elements 
    between :math:`a` and :math:`b` is 

    .. math:: 

        a,\ ar^1,\ ar^2,\ \dots,\ ar^{n-1}

    where the ratio :math:`r` is

    .. math:: 

        r = (\\frac{b}{a})^{\\frac{1}{n-1}}

    Examples
    --------
    >>> biolearning.tools.geometric_range(0.0, 10.0, 4)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "biolearning/tools.py", line 118, in geometric_range
        >>> biolearning.tools.geometric_range(0.1, 10.0, 1)
    ZeroDivisionError: float division
    >>> biolearning.tools.geometric_range(0.1, 10.0, 4)
    array([ 0.1       ,  0.46415888,  2.15443469, 10.        ])
    >>> biolearning.tools.geometric_range(0.1, 10.0, 2)
    array([  0.1,  10. ])
    >>> biolearning.tools.geometric_range(0.1, 10.0, 1)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "biolearning/tools.py", line 118, in geometric_range
        >>> biolearning.tools.geometric_range(0.1, 10.0, 1)
    ZeroDivisionError: float division
    >>> biolearning.tools.geometric_range(0.1, 10.0, 0)
    array([], dtype=float64)

    """
    ratio = (max_value/float(min_value))**(1.0/(number-1))
    return min_value * (ratio ** np.arange(number))

# Normalization ---------------------------------------------------------------
def standardize(matrix, optional_matrix=None, return_factors=False):
    """Standardize columns of a matrix.

    Returns the standardized ``matrix`` given in input.
    Optionally standardizes an ``optional_matrix`` respect 
    mean and standard deviation calculated on ``matrix``.

    Parameters
    ----------
    matrix : (N,) or (N, D) ndarray
        Input matrix whose columns are to be standardize 
        to mean=0 and standard deviation=1. 
    optional_matrix : (N,) or (N, D) ndarray, optional (default is `None`)
        Optional matrix whose columns are to be standardize
        using mean and standard deviation of ``matrix``.
        It must have same columns number of ``matrix``.
    return_factors : bool, optional (default is `False`)
        If `True` returns used mean and standard deviation.

    Returns
    -------
    matrix_standardized : (N,) or (N, D) ndarray
        Standardized ``matrix``.
        If ``matrix`` is an (N,) ndarray then returns its standardization.
    optional_matrix_standardized : (N,) or (N, D) ndarray, optional
        Standardized ``optional_matrix`` respect to ``matrix``
    mean : float or (D,) ndarray, optional
        Mean of ``matrix`` columns.
    std : float or (D,) ndarray, optional
        Standard deviation of ``matrix`` columns.

    See Also
    --------
    center

    Examples
    --------
    >>> X = numpy.array([[1, 2, 3], [4, 5, 6]])
    >>> biolearning.tools.standardize(X)
    array([[-0.70710678, -0.70710678, -0.70710678],
           [ 0.70710678,  0.70710678,  0.70710678]])
    >>> biolearning.tools.standardize(X, return_factors=True)
    (array([[-0.70710678, -0.70710678, -0.70710678],
            [ 0.70710678,  0.70710678,  0.70710678]]),
     array([ 2.5,  3.5,  4.5]),
     array([ 2.12132034,  2.12132034,  2.12132034]))
    >>> x = numpy.array([1, 2, 3])
    >>> biolearning.tools.standardize(x)
    array([-1.,  0.,  1.])

    """
    mean = matrix.mean(axis=0)
    std = matrix.std(axis=0, ddof=1)

    # Simple case
    if optional_matrix is None and return_factors is False:
        return (matrix - mean)/std
                
    if optional_matrix is None: # than return_factors is True
        return (matrix - mean)/std, mean, std
        
    if return_factors is False: # ... with p not None
        return (matrix - mean)/std, (optional_matrix - mean)/std
        
    # Full case
    return (matrix - mean)/std, (optional_matrix - mean)/std, mean, std
    
def center(matrix, optional_matrix=None, return_mean=False):
    """Center columns of a matrix.

    Returns the centered ``matrix`` given in input.
    Optionally centers an ``optional_matrix`` respect 
    mean calculated on ``matrix``.

    Parameters
    ----------
    matrix : (N,) or (N, D) ndarray
        Input matrix whose columns are to be center.
    optional_matrix : (N,) or (N, D) ndarray, optional (default is `None`)
        Optional matrix whose columns are to be center
        using mean of ``matrix``.
        It must have same columns number of ``matrix``.
    return_mean : bool, optional (default is `False`)
        If `True` returns used mean.

    Returns
    -------
    matrix_centered : (N,) or (N, D) ndarray
        Centered ``matrix``.
        If ``matrix`` is an (N,) ndarray then returns its centering.
    optional_matrix_centered : (N,) or (N, D) ndarray, optional
        Centered ``optional_matrix`` respect to ``matrix``
    mean : float or (D,) ndarray, optional
        Mean of ``matrix`` columns.

    See Also
    --------
    standardize

    Examples
    --------
    >>> X = numpy.array([[1, 2, 3], [4, 5, 6]])
    >>> biolearning.tools.center(X)
    array([[-1.5, -1.5, -1.5],
           [ 1.5,  1.5,  1.5]])
    >>> biolearning.tools.center(X, return_mean=True)
    (array([[-1.5, -1.5, -1.5],
            [ 1.5,  1.5,  1.5]]),
     array([ 2.5,  3.5,  4.5]))
    >>> x = numpy.array([1, 2, 3])
    >>> biolearning.tools.center(x)
    array([-1.,  0.,  1.])

    """
    mean = matrix.mean(axis=0)
    
    # Simple case
    if optional_matrix is None and return_mean is False:
        return matrix - mean
    
    if optional_matrix is None: # than return_mean is True
        return (matrix - mean, mean)
    
    if return_mean is False: # ...with p not None
        return (matrix - mean, optional_matrix - mean)
    
    # Full case
    return (matrix - mean, optional_matrix - mean, mean)
    
# Error functions -------------------------------------------------------------
def classification_error(labels, predicted):
    """Returns classification error.

    The classification error is based on the sign of the ``predicted`` values
    respect the sign of the data ``labels``.
    The functions assumes that ``labels`` contains positive number for one
    class and negative numbers for the other one (see ``Notes``).

    Parameters
    ----------
    labels : array_like
        Descr.
    predicted : array_like
        Descr.

    Returns
    -------
    error : float
        Descr.

    See Also
    --------
    balanced_classification_error
    regression_error    

    Notes
    ------
    .. math::

        error = \\frac{\sum_{i=1}^N{f(l_i, p_i)}}{N} \qquad 
                l_i \in labels,\quad p_i \in predicted

    where :math:`f(l, p)=1` if :math:`sign(l)=sign(p)`, otherwise
    :math:`f(l, p)=0`

    Examples
    --------
    >>> 

    TODO: raise error if labels.size != predicted.size 
    TODO: todo, respect the array_like!

    """
    difference = (np.sign(labels) != np.sign(predicted))
    return labels[difference].size / float(labels.size)
    
def balanced_classification_error(labels, predicted):
    """ TODO: Add docstring """
    balance_factors = np.abs(center(labels)[0])
   
    errors = (np.sign(labels) != np.sign(predicted)) * balance_factors
    return errors.sum() / float(labels.size)
    
def regression_error(labels, predicted):
    """ TODO: Add docstring """
    norm = np.linalg.norm(labels - predicted, 2)
    return (norm * norm) / float(labels.size)
    
# KCV tools -------------------------------------------------------------------
def kfold_splits(labels, k, rseed=0):
    """ TODO: Add docstring """
    import mlpy
    return mlpy.kfold(labels.size, k, rseed)

def stratified_kfold_splits(labels, k, rseed=0):
    """ TODO: Add docstring """
    import mlpy
    return mlpy.kfoldS(labels, k, rseed)
